#+TITLE: pytest Fixtures

Here is a simple fixture that returns a number:

#+BEGIN_SRC python :tangle ch3/test_fixtures.py
import pytest

@pytest.fixture()
def some_data():
    """Return answer to ultimate question"""
    return 42

def test_some_data(some_data):
    """Use fixture return value in a test"""
    assert some_data == 42
#+END_SRC

* Sharing Fixtures Through conftest.py

To share fixtures among multiple test files, you need to use a conftest.py file somewhere centrally located for all of the tests.

The conftest.py file gets read by pytest and is considered a local plugin. It is not imported anywhere.

* Using Fixtures for Setup and Teardown

#+BEGIN_SRC python :tangle ch3/conftest.py
import pytest
import tasks
from tasks import Task

@pytest.fixture()
def tasks_db(tmpdir):
    """Connect to db before tests, disconnect after."""
    # setup: start db
    tasks.start_tasks_db(str(tmpdir), "tiny")

    yield # this is where the testing happens

    # teardown: stop db
    tasks.stop_tasks_db()
#+END_SRC

#+BEGIN_SRC python :tangle ch3/tests/func/add_test.py
import pytest
import tasks
from tasks import Task

def test_add_returns_valid_id(tasks_db):
    """tasks.add(<valid task>) should return an integer"""
    # GIVEN an initialized tasks db
    # WHEN a new task is added
    # THEN returned task_id is of type int
    new_task = Task("do something")
    task_id = tasks.add(new_task)
    assert isinstance(task_id, int)
#+END_SRC

You can view fixture execution with the --setup-show flag

#+BEGIN_SRC bash
pytest --setup-show test_add.py -k valid_id
#+END_SRC

* Using Fixtures for Test Data

Fixtures are a great place to store data to use for testing.

#+BEGIN_SRC python :tangle ch3/test_fixtures.py
@pytest.fixture()
def a_tuple():
    """Return something more interesting"""
    return (1, "foo", None, {"bar": 23})

def test_a_tuple(a_tuple):
    """Demo the a_tuple fixture."""
    assert a_tuple[3]["bar"] == 32
#+END_SRC

#+BEGIN_SRC python :tangle ch3/tasks_proj/conftest.py
@pytest.fixture()
def tasks_just_a_few():
    """All summaries and owners are unique"""
    return (
        Task("Write some code", "Brian", True),
        Task("Code review Brian's code", "Katie", False),
        Task("Fix what Brian did", "Michelle", False)
    )

@pytest.fixture()
def tasks_mult_per_owner():
    """Several owners with several tasks each."""
    return (
        Task("Write some code", "Brian", True),
        Task("Code review Brian's code", "Katie", False),
        Task("Fix what Brian did", "Michelle", False),
        Task("Write some more code", "Brian", True),
        Task("Code review Brian's new code", "Katie", False),
        Task("Fix what Brian did again", "Michelle", False),
        Task("Write some other code", "Brian", True),
        Task("Code review Brian's other code", "Katie", False),
        Task("Fix what Brian did once more", "Michelle", False)
    )
#+END_SRC

* Using Multiple Fixtures

We've seen that tmpdir uses tmpdir_factory. Let's add some specialized fixtures for non-empty tasks databases:

#+BEGIN_SRC python :tangle ch3/tasks_proj/conftest.py
@pytest.fixture()
def db_with_3_tasks(tasks_db, tasks_just_a_few):
    """Connected db with 3 tasks, all unique"""
    for t in tasks_just_a_few:
        tasks.add(t)

@pytest.fixture()
def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner):
    """Connected db with 9 tasks, 3 owners, all with 3 tasks"""
    for t in tasks_mult_per_owner:
        tasks.add(t)
#+END_SRC

These fixtures all include two fixtures each in their parameter list: tasks_db and a dataset.
The dataset is used to add tasks to the database. Now tests can use these when you want the test to start from a non-empty database

#+BEGIN_SRC python :tangle ch3/tasks_proj/tests/func/test_add.py
def test_add_increases_count(db_with_3_tasks):
    """Test tasks.add() affect on tasks.count()"""
    # GIVEN a db with 3 tasks
    # WHEN another task is added
    tasks.add(Task("Throw a party"))
    # THEN the count increases by 1
    assert tasks.count() == 4
#+END_SRC
